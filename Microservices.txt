->Microservices:
a)Microservices are a software architectural style in which a large application is built as a collection of small, independent services that communicate with each other over a network. 
b)Each service is a self-contained unit of functionality that can be developed, tested, and deployed independently of the other services. 
c)This allows for more flexibility and scalability than a monolithic architecture, where all the functionality is contained in a single, large codebase. 
d)Microservices can be written in different programming languages and use different technologies, as long as they can communicate with each other through a common API. 
e)They are designed to be loosely coupled, meaning that changes to one service should not affect the other services. This makes it easier to update, maintain, and scale the application. 
f)Microservices architecture is best suited for large and complex applications that need to handle a high volume of traffic and need to be scaled horizontally..


->Key Components of a Microservices Architecture
1.Core Services:
 Each service is a self-contained unit of functionality that can be developed, tested, and deployed independently of the other services.

2.Service registry: 
A service registry is a database of all the services in the system, along with their locations and capabilities. It allows services to discover and communicate with each other.

3.API Gateway: 
An API gateway is a single entry point for all incoming requests to the microservices. It acts as a reverse proxy, routing requests to the appropriate service and handling tasks such as authentication and rate limiting.

4.Message bus:
 A message bus is a messaging system that allows services to communicate asynchronously with each other. This can be done through protocols like HTTP, RabbitMQ, or Kafka.

5.Monitoring and logging:
 Monitoring and logging are necessary to track the health of the services and troubleshoot problems.

6.Service discovery and load balancing:
 This component is responsible for discovering service instances and directing traffic to the appropriate service instances based on load and availability.

7.Continuous integration and continuous deployment (CI/CD): 
To make the development and deployment process of microservices as smooth as possible, it is recommended to use a tool such as Jenkins, TravisCI, or CircleCI to automate the process of building, testing, and deploying microservices.


->What is Microservices Architecture?
The idea of microservices is straightforward. It ought to break an enormous service with numerous little free services. We should examine a few significant places of Microservices in view of beneath design:

Each micro service has its own information base.  
Client API don't have direct admittance to the services. 
It can associate through API passage. We will enroll each service with the revelation server. 
The disclosure has data of all the microservices accessible in the framework.

Design server contains every one of the arrangements for the microservices and we will utilize this server to get setup data like hostname, URL and so on for our microservices.


->Three Main types of Microservices:
1.RestTemplate
2.Webclient
3.Spring cloud open feign.

->InterProcess Communication:
1.RestTemplate:
a)Configure Bean method in Springboot Main class.
    @Bean
    RestTemplate restTemplate() {
		return new RestTemplate();
	}

b)Configure the Rest client Method in Service call:
Example:
	RestTemplate restTemplate = new RestTemplate();
	HttpHeaders headers = new HttpHeaders();
	headers.setContentType(MediaType.APPLICATION_JSON);
	headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));
	HttpEntity<String> entity = new HttpEntity<String>(orderDetails.getOrderName(), headers);
	String url = "http://localhost:8080/product/createproduct";
	ResponseVO response = restTemplate.exchange(url, HttpMethod.POST, entity, ResponseVO.class).getBody();

2.Webclient:
https://teams.microsoft.com/l/message/48:notes/1694668493931?context=%7B%22contextType%22%3A%22chat%22%7D
https://github.com/BarathArivazhagan/spring-webflux-rest-webclient
https://teams.microsoft.com/l/message/48:notes/1694668446565?context=%7B%22contextType%22%3A%22chat%22%7D
a)Add Webflux dependency:

b)Configure Bean method in Springboot Main class.
   @Bean
    public WebClient.Builder webClientBuilder() {
        return WebClient.builder();
    }

c)Configure the Rest client Method in Service call:
		@Autowired
		WebClient webClient;
public Mono<SubjectNotes> getSubjectById(String id) {
		return webClient.get()
		.uri("/posts/{id}", id)
		.retrieve()
		.bodyToMono(SubjectNotes.class);
			}

-----------------------------------------------------------------------------------------------------------
->Spring cloud Netflix Eureka server:
Eureka Server and client:
a)eureka server:
1.Add dependency of eureka server:
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
		</dependency>
2.Annotate with @EnableEurekaServer in springboot main class.
3.Configure the properties of Eureka server in application.properties:
eureka.instance.hostname=localhost
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false
server.port=8761


b)eureka Client:
1.Add dependency of eureka server:
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
		</dependency>
2.Annotate with @EnableEurekaClient in springboot main class.
3.Configure the properties of Eureka server in application.properties:
#eureka
eureka.client.service-url.defaultZone=http://localhost:8761/eureka
spring.application.name=notification-service


-----------------------------------------------------------------------------------------------------------
->Spring API Gateway:
1.API Gateway:
a)Microservices will have multiple instances and applications run on different ports,
we cannot hardcode/rely on the service names in codebase.

b)To overcome this:
1.Implementing a component acts as a starting point for any request as API gateway responsible
for routing the incoming requests to respective services.

->API Gateway Acts as:
1.Routing based on reqeusts headers
2.Authentication
3.Security
4.Load balancing
5.SSL Termination.

->Popular Gateway :
1.APG
2.Cong API Gateway

->API Gateway Has three main properties:
1.Route: The basic building block of the gateway. 
It is defined by an ID, a destination URI, a collection of predicates, and a collection of filters. 
A route is matched if the aggregate predicate is true.

2.Predicate: This is a Java 8 Function Predicate. 
The input type is a Spring Framework ServerWebExchange. 
This lets you match on anything from the HTTP request, such as headers or parameters.

3.Filter: These are instances of GatewayFilter that have been constructed with a specific factory. 
Here, you can modify requests and responses before or after sending the downstream request.


2.Create a maven project and Add speing cloud gateway dependency and Eureka client
3.Annotate with @EnableEurekaClient and configure the properties of Eureka server in application.properties:
#eureka
eureka.client.service-url.defaultZone=http://localhost:8761/eureka
spring.application.name=api-gateway.
server.port=0

4.add logging level properties:
5.Add routing properties for multiple services:
#Product service
spring.cloud.gateway.routes[0].id=product-service
spring.cloud.gateway.routes[0].uri=lb://product-service
spring.cloud.gateway.routes[0].predicate[0]=Path=/products

#order service
spring.cloud.gateway.routes[1].id=order-service
spring.cloud.gateway.routes[1].uri=lb://order-service
spring.cloud.gateway.routes[1].predicate[0]=Path=/orders

#notification service
spring.cloud.gateway.routes[2].id=notification-service
spring.cloud.gateway.routes[2].uri=lb://notification-service
spring.cloud.gateway.routes[2].predicate[0]=Path=/email

#discovery service
spring.cloud.gateway.routes[2].id=discovery-service
spring.cloud.gateway.routes[2].uri=http://localhost:8761
spring.cloud.gateway.routes[2].predicate[0]=Path=/eureka/web
spring.cloud.gateway.routes[2].filters[0]=setPath=/

#discovery service static resources route:
spring.cloud.gateway.routes[3].id=discovery-server-static
spring.cloud.gateway.routes[3].uri=http://localhost:8761
spring.cloud.gateway.routes[3].predicate[0]=Path=/eureka/**

